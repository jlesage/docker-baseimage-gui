#
# This patch adds the ability to configure a different security type for
# internal connection (e.g. Unix domain socket).
#
--- a/common/rfb/SConnection.cxx
+++ b/common/rfb/SConnection.cxx
@@ -49,7 +49,9 @@ using namespace rfb;
 static core::LogWriter vlog("SConnection");
 
 SConnection::SConnection(AccessRights accessRights_)
-  : readyForSetColourMapEntries(false), is(nullptr), os(nullptr),
+  : readyForSetColourMapEntries(false),
+    isInternal(false),
+    is(nullptr), os(nullptr),
     reader_(nullptr), writer_(nullptr), ssecurity(nullptr),
     authFailureTimer(this, &SConnection::handleAuthFailureTimeout),
     state_(RFBSTATE_UNINITIALISED), preferredEncoding(encodingRaw),
@@ -76,6 +78,17 @@ void SConnection::setStreams(rdr::InStream* is_, rdr::OutStream* os_)
   os = os_;
 }
 
+void SConnection::setInternal(bool internal)
+{
+  isInternal = internal;
+  security.UpdateSecTypes(internal);
+}
+
+bool SConnection::getInternal()
+{
+  return isInternal;
+}
+
 void SConnection::initialiseProtocol()
 {
   char str[13];
--- a/common/rfb/SConnection.h
+++ b/common/rfb/SConnection.h
@@ -59,6 +59,11 @@ namespace rfb {
     // (i.e. SConnection will not delete them).
     void setStreams(rdr::InStream* is, rdr::OutStream* os);
 
+    // setInternal() is used to indicate if this is an internal connection, like
+    // from a Unix Domain Socket.
+    void setInternal(bool internal);
+    bool getInternal();
+
     // initialiseProtocol() should be called once the streams and security
     // types are set.  Subsequently, processMsg() should be called whenever
     // there is data to read on the InStream.
@@ -273,6 +278,8 @@ namespace rfb {
 
     int defaultMajorVersion, defaultMinorVersion;
 
+    bool isInternal;
+
     rdr::InStream* is;
     rdr::OutStream* os;
 
--- a/common/rfb/SecurityServer.cxx
+++ b/common/rfb/SecurityServer.cxx
@@ -64,6 +64,30 @@ core::EnumListParameter SecurityServer::secTypes
 #endif
  "VncAuth"});
 
+core::EnumListParameter SecurityServer::internalConnectionSecTypes
+("InternalConnectionSecurityTypes",
+ "Specify which security scheme to use for internal connections (None, VncAuth, Plain"
+#ifdef HAVE_GNUTLS
+ ", TLSNone, TLSVnc, TLSPlain, X509None, X509Vnc, X509Plain"
+#endif
+#ifdef HAVE_NETTLE
+ ", RA2, RA2ne, RA2_256, RA2ne_256"
+#endif
+ ")",
+ { "None", "VncAuth", "Plain",
+#ifdef HAVE_GNUTLS
+ "TLSNone", "TLSVnc", "TLSPlain", "X509None", "X509Vnc", "X509Plain",
+#endif
+#ifdef HAVE_NETTLE
+ "RA2", "RA2ne", "RA2_256", "RA2ne_256",
+#endif
+ },
+ {
+#ifdef HAVE_GNUTLS
+ "TLSVnc",
+#endif
+ "VncAuth"});
+
 SSecurity* SecurityServer::GetSSecurity(SConnection* sc, uint32_t secType)
 {
   if (!IsSupported(secType))
@@ -104,3 +128,32 @@ bail:
   throw std::invalid_argument("Security type not supported");
 }
 
+void SecurityServer::UpdateSecTypes(bool internalConnection)
+{
+  std::list<uint32_t> newSecTypes;
+
+  if (internalConnection) {
+    for (core::EnumListEntry type : internalConnectionSecTypes) {
+      uint32_t typeNum = secTypeNum(type.getValueStr().c_str());
+      // Should have been filtered by EnumListParameter, but let's have
+      // a safety net
+      if (typeNum == secTypeInvalid)
+        throw std::logic_error("Unknown security type");
+      newSecTypes.push_back(typeNum);
+    }
+  }
+
+  if (newSecTypes.size() == 0) {
+    for (core::EnumListEntry type : secTypes) {
+      uint32_t typeNum = secTypeNum(type.getValueStr().c_str());
+      // Should have been filtered by EnumListParameter, but let's have
+      // a safety net
+      if (typeNum == secTypeInvalid)
+        throw std::logic_error("Unknown security type");
+      newSecTypes.push_back(typeNum);
+    }
+  }
+
+  SetSecTypes(newSecTypes);
+}
+
--- a/common/rfb/SecurityServer.h
+++ b/common/rfb/SecurityServer.h
@@ -34,7 +34,10 @@ namespace rfb {
     /* Create server side SSecurity class instance */
     SSecurity* GetSSecurity(SConnection* sc, uint32_t secType);
 
+    void UpdateSecTypes(bool internalConnection);
+
     static core::EnumListParameter secTypes;
+    static core::EnumListParameter internalConnectionSecTypes;
   };
 
 }
--- a/common/rfb/VNCSConnectionST.cxx
+++ b/common/rfb/VNCSConnectionST.cxx
@@ -29,6 +29,8 @@
 #include <rdr/FdInStream.h>
 #include <rdr/FdOutStream.h>
 
+#include <sys/socket.h>
+
 #include <network/TcpSocket.h>
 
 #include <rfb/ComparingUpdateTracker.h>
@@ -79,6 +81,17 @@ VNCSConnectionST::VNCSConnectionST(VNCServerST* server_, network::Socket *s,
     else
       idleTimer.start(core::secsToMillis(rfb::Server::idleTimeout));
   }
+
+  // Determine is this is an internal connection
+  {
+    struct sockaddr addr;
+    socklen_t salen = sizeof(addr);
+    if (getsockname(sock->getFd(), &addr, &salen) == 0) {
+      if (addr.sa_family == AF_UNIX) {
+        setInternal(true);
+      }
+    }
+  }
 }
 
 
